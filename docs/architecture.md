# Архитектура проекта CPU Optimized App

## Содержание

1. [Обзор архитектуры](#обзор-архитектуры)
2. [Основные компоненты](#основные-компоненты)
3. [Принципы работы](#принципы-работы)
4. [Взаимодействие компонентов](#взаимодействие-компонентов)
5. [Оптимизации для различных архитектур](#оптимизации-для-различных-архитектур)
6. [Аллокаторы памяти](#аллокаторы-памяти)
7. [Асинхронная обработка](#асинхронная-обработка)
8. [Схемы и диаграммы](#схемы-и-диаграммы)

## Обзор архитектуры

CPU Optimized App использует архитектуру с динамической загрузкой
библиотек, оптимизированных для конкретных архитектур процессоров.
Это позволяет достичь максимальной производительности на различных
платформах без необходимости компиляции всего приложения под каждую
архитектуру.

Архитектура проекта состоит из двух основных частей:

1. **Основное приложение** - определяет архитектуру процессора и
   загружает соответствующую библиотеку
2. **Динамические библиотеки** - содержат оптимизированный код для
   различных архитектур процессоров

Такой подход обеспечивает следующие преимущества:

- Оптимальная производительность на различных архитектурах
- Возможность выбора оптимального аллокатора памяти
- Гибкость в настройке и расширении функциональности
- Минимальный размер основного приложения

## Основные компоненты

### Основное приложение

Основное приложение состоит из следующих модулей:

- **main.rs** - точка входа в приложение, координирует работу
  остальных модулей
- **cpu_detection.rs** - определяет архитектуру процессора и
  поддерживаемые наборы инструкций
- **lib_loader.rs** - загружает динамические библиотеки и вызывает
  функции из них
- **error.rs** - обрабатывает ошибки, возникающие в процессе работы
  приложения

### Динамические библиотеки

Динамические библиотеки содержат оптимизированный код для различных
архитектур процессоров:

- **core_lib** - основная библиотека с оптимизациями
  - **lib.rs** - точка входа в библиотеку, содержит функцию `run`
  - **error.rs** - обрабатывает ошибки, возникающие в процессе работы
    библиотеки
  - **runtime.rs** - содержит основную логику выполнения библиотеки

### Вспомогательные компоненты

- **scripts/build.sh** - скрипт для сборки проекта с различными
  параметрами
- **scripts/benchmark.sh** - скрипт для запуска бенчмарков и
  сравнения производительности
- **Makefile** - автоматизация процесса сборки
- **Dockerfile** - сборка проекта в контейнере

## Принципы работы

Основной принцип работы приложения заключается в следующем:

1. Определение архитектуры процессора и поддерживаемых наборов
   инструкций
2. Выбор оптимальной библиотеки на основе полученной информации
3. Загрузка выбранной библиотеки
4. Вызов функции `run` из загруженной библиотеки
5. Обработка результатов выполнения

### Определение архитектуры процессора

Для определения архитектуры процессора используется библиотека
`raw-cpuid`, которая предоставляет доступ к инструкции CPUID на
процессорах x86_64. Для архитектуры ARM используются альтернативные
методы, такие как чтение информации из `/proc/cpuinfo` на Linux.

Процесс определения архитектуры процессора включает:

1. Определение производителя процессора (Intel, AMD, ARM и т.д.)
2. Определение модели процессора
3. Определение поддерживаемых наборов инструкций (AVX2, AVX, SSE4.2,
   NEON и т.д.)

### Выбор оптимальной библиотеки

На основе полученной информации о процессоре выбирается оптимальная
библиотека:

1. Определение наилучшего набора инструкций среди поддерживаемых
2. процессором
3. Формирование имени библиотеки в формате
   `{arch}_{features}_{allocator}`
4. Поиск библиотеки в директории `lib`
5. Если оптимальная библиотека не найдена, поиск запасного варианта

### Загрузка библиотеки и вызов функций

Для загрузки библиотеки и вызова функций из нее используется
библиотека `libloading`:

1. Загрузка библиотеки с помощью `Library::new`
2. Получение функции `run` из библиотеки с помощью `lib.get(b"run")`
3. Вызов функции `run` с передачей аргументов командной строки
4. Обработка результатов выполнения

## Взаимодействие компонентов

Взаимодействие компонентов приложения происходит следующим образом:

1. **main.rs** инициализирует логгер и запускает основную логику
2. **cpu_detection.rs** определяет архитектуру процессора и
   возвращает информацию о ней
3. **lib_loader.rs** выбирает и загружает оптимальную библиотеку
4. **core_lib/lib.rs** инициализирует библиотеку и запускает основную
   логику
5. **core_lib/runtime.rs** обрабатывает аргументы командной строки и
   выполняет соответствующие действия

### Диаграмма последовательности

```text
main.rs          cpu_detection.rs    lib_loader.rs       core_lib/lib.rs    core_lib/runtime.rs
   |                    |                 |                     |                    |
   | инициализация      |                 |                     |                    |
   |------------------>|                 |                     |                    |
   |                    |                 |                     |                    |
   | detect_cpu()       |                 |                     |                    |
   |------------------>|                 |                     |                    |
   |                    |                 |                     |                    |
   | CpuInfo            |                 |                     |                    |
   |<------------------|                 |                     |                    |
   |                    |                 |                     |                    |
   | find_library()     |                 |                     |                    |
   |---------------------------------->|                     |                    |
   |                    |                 |                     |                    |
   | lib_path           |                 |                     |                    |
   |<----------------------------------|                     |                    |
   |                    |                 |                     |                    |
   | load_and_run()     |                 |                     |                    |
   |---------------------------------->|                     |                    |
   |                    |                 |                     |                    |
   |                    |                 | Library::new()      |                    |
   |                    |                 |-------------------->|                    |
   |                    |                 |                     |                    |
   |                    |                 | run()               |                    |
   |                    |                 |-------------------->|                    |
   |                    |                 |                     |                    |
   |                    |                 |                     | run_with_args()    |
   |                    |                 |                     |------------------->|
   |                    |                 |                     |                    |
   |                    |                 |                     | результат          |
   |                    |                 |                     |<-------------------|
   |                    |                 |                     |                    |
   |                    |                 | результат           |                    |
   |                    |                 |<--------------------|                    |
   |                    |                 |                     |                    |
   | результат          |                 |                     |                    |
   |<----------------------------------|                     |                    |
   |                    |                 |                     |                    |
```

## Оптимизации для различных архитектур

Проект поддерживает оптимизации для различных архитектур процессоров:

### x86_64

- **AVX2** - Advanced Vector Extensions 2, расширение набора
  инструкций x86, добавляющее 256-битные SIMD-инструкции
- **AVX** - Advanced Vector Extensions, расширение набора инструкций
  x86, добавляющее 256-битные SIMD-инструкции
- **SSE4.2** - Streaming SIMD Extensions 4.2, расширение набора
  инструкций x86, добавляющее 128-битные SIMD-инструкции

### ARM64 (aarch64)

- **NEON** - расширение набора инструкций ARM, добавляющее
  SIMD-инструкции

### Реализация оптимизаций

Оптимизации реализуются с помощью условной компиляции в Rust:

```rust
#[cfg(feature = "avx2")]
{
    // Код, оптимизированный для AVX2
}

#[cfg(all(feature = "avx", not(feature = "avx2")))]
{
    // Код, оптимизированный для AVX
}

#[cfg(all(feature = "sse4_2", not(feature = "avx"), not(feature = "avx2")))]
{
    // Код, оптимизированный для SSE4.2
}

#[cfg(not(any(feature = "avx2", feature = "avx", feature = "sse4_2")))]
{
    // Базовый код без оптимизаций
}
```

## Аллокаторы памяти

Проект поддерживает различные аллокаторы памяти:

- **system** - стандартный системный аллокатор
- **jemalloc** - аллокатор jemalloc для более эффективного управления
  памятью
- **mimalloc** - аллокатор mimalloc для более эффективного управления
  памятью

### Выбор аллокатора

Выбор аллокатора осуществляется с помощью features при компиляции
библиотеки:

```rust
#[cfg(feature = "jemalloc-allocator")]
#[global_allocator]
static GLOBAL: jemallocator::Jemalloc = jemallocator::Jemalloc;

#[cfg(feature = "mimalloc-allocator")]
#[global_allocator]
static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;
```

## Асинхронная обработка

Для асинхронной обработки данных используется библиотека Tokio:

1. Создание асинхронной среды выполнения с помощью
   `tokio::runtime::Builder`
2. Настройка параметров среды выполнения (количество потоков, размер
   стека и т.д.)
3. Запуск асинхронных задач с помощью `tokio::spawn`
4. Ожидание завершения задач с помощью `handle.await`

### Пример асинхронной обработки

```rust
// Создание асинхронной среды выполнения
let runtime = tokio::runtime::Builder::new_multi_thread()
    .worker_threads(threads)
    .thread_stack_size(stack_size * 1024)
    .max_blocking_threads(max_tasks)
    .enable_all()
    .build()?;

// Запуск асинхронных задач
runtime.block_on(async {
    let mut handles = Vec::with_capacity(iterations);
    
    for i in 0..iterations {
        let handle = tokio::spawn(async move {
            // Асинхронная обработка данных
            // ...
            i
        });
        handles.push(handle);
    }
    
    // Ожидание завершения всех задач
    for handle in handles {
        let result = handle.await?;
        // Обработка результатов
        // ...
    }
    
    Ok(0)
})
```

## Схемы и диаграммы

### Общая архитектура проекта

```text
+----------------------------------+
|        Основное приложение       |
|                                  |
|  +-------------+  +------------+ |
|  |cpu_detection|  | lib_loader | |
|  +-------------+  +------------+ |
|         ^               ^        |
|         |               |        |
|         v               v        |
|      +------------------+        |
|      |      main        |        |
|      +------------------+        |
+----------------------------------+
              |
              v
+----------------------------------+
|      Динамические библиотеки     |
|                                  |
| +------------------------------+ |
| |          core_lib            | |
| |                              | |
| | +------------+ +----------+  | |
| | |    lib     | | runtime  |  | |
| | +------------+ +----------+  | |
| +------------------------------+ |
+----------------------------------+
```

### Процесс выбора и загрузки библиотеки

```text
+------------------+     +------------------+     +------------------+
| Определение      |     | Выбор            |     | Загрузка         |
| архитектуры      | --> | оптимальной      | --> | библиотеки       |
| процессора       |     | библиотеки       |     |                  |
+------------------+     +------------------+     +------------------+
                                                          |
                                                          v
+------------------+     +------------------+     +------------------+
| Обработка        |     | Вызов функции    |     | Получение        |
| результатов      | <-- | run из           | <-- | функции run      |
|                  |     | библиотеки       |     | из библиотеки    |
+------------------+     +------------------+     +------------------+
```

### Структура директорий проекта

```text
project/
├── Cargo.toml          - Основной файл конфигурации проекта
├── Makefile            - Файл для автоматизации сборки
├── Dockerfile          - Файл для сборки в контейнере
├── README.md           - Документация проекта
├── src/                - Исходный код основного приложения
│   ├── main.rs         - Точка входа в приложение
│   ├── cpu_detection.rs- Определение архитектуры процессора
│   ├── lib_loader.rs   - Загрузка динамических библиотек
│   └── error.rs        - Обработка ошибок
├── core_lib/           - Исходный код оптимизированной библиотеки
│   ├── Cargo.toml      - Файл конфигурации библиотеки
│   ├── src/            - Исходный код библиотеки
│   │   ├── lib.rs      - Точка входа в библиотеку
│   │   ├── error.rs    - Обработка ошибок
│   │   └── runtime.rs  - Основная логика выполнения
│   └── benches/        - Бенчмарки для измерения производительности
│       └── performance_benchmarks.rs
├── lib/                - Директория для скомпилированных библиотек
├── tests/              - Тесты проекта
│   ├── integration_tests.rs
│   └── cross_platform_tests.rs
├── scripts/            - Скрипты для сборки и тестирования
│   ├── build.sh        - Скрипт для сборки проекта
│   └── benchmark.sh    - Скрипт для запуска бенчмарков
└── docs/               - Документация
    ├── user_guide.md   - Руководство пользователя
    ├── build_install.md- Руководство по сборке и установке
    └── architecture.md - Описание архитектуры проекта
```
