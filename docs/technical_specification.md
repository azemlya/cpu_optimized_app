# Техническое задание

## Цель проекта

Создать проект Rust с основным бинарным файлом, который определяет
архитектуру процессора и загружает соответствующую динамическую
библиотеку, оптимизированную для этой архитектуры.

## Основные требования

### Бинарный запускаемый файл

- Бинарный запускаемый файл компилируется без специфичных оптимизаций
  под конкретный процессор (только общие стандартные оптимизации).
- При запуске определяет тип процессора и поддерживаемые им наборы
  инструкций.
- Загружает соответствующую динамически подключаемую библиотеку из
  поддиректории `lib`.
- Выводит в stderr информацию о:
  - Типе процессора
  - Поддерживаемых наборах инструкций
  - Версии операционной системы
  - Версии библиотеки `libc`
  - Выбранной динамической библиотеке
  - Используемом аллокаторе памяти
  - Другой полезной для отладки информации
- Передает аргументы командной строки в функцию `run` загруженной
  библиотеки.
- Корректно обрабатывает ошибки загрузки библиотеки и вызова функции
  `run`.
- Возвращает код возврата, полученный от функции `run`.

### Динамически подключаемые библиотеки

- Код динамически подключаемой библиотеки находится в отдельном
  крейте `core_lib`.
- Библиотеки компилируются отдельно под каждую современную
  процессорную архитектуру (64-битные процессоры выпущенные позже
  2010 года).
- Один и тот же исходный код компилируется с разными флагами
  оптимизации для разных архитектур.
- Используются различные аллокаторы памяти, выбираемые через
  features:
  - jemalloc
  - mimalloc
  - system (стандартный системный аллокатор)
- Наименование динамически подключаемых библиотек следует формату:
  `lib/{arch}_{features}_{allocator}.{ext}`, где:
  - `{arch}` - основная архитектура (x86_64, aarch64)
  - `{features}` - конкретный набор инструкций (avx2, avx, sse4.2,
    neon)
  - `{allocator}` - используемый аллокатор (jemalloc, mimalloc,
    system)
  - `{ext}` - расширение файла библиотеки (.so, .dll, .dylib)
- Библиотеки должны находиться в поддиректории `lib` относительно
  запускаемого бинарного файла.
- Не используются аллокаторы памяти, которые не поддерживаются на
  разных платформах.
- В библиотеках инициализируется логгер (крейты log и env_logger).
- В библиотеках инициализируется асинхронная среда выполнения tokio.

### Сигнатура функции `run`

```rust
pub fn run(args: Vec<String>) -> Result<i32, CoreError>
```

где:

- `args: Vec<String>` - аргументы командной строки
- `Result<i32, CoreError>` - результат выполнения, где:
  - `i32` - код возврата (0 - успешное выполнение)
  - `CoreError` - пользовательский тип ошибки, реализующий трейты
    `std::error::Error` и `std::fmt::Display`

### Обработка ошибок

- Использовать идиоматичный для Rust подход с типом `Result<T, E>`.
- Создать собственный тип ошибки `CoreError`, который реализует
  трейты `std::error::Error` и `std::fmt::Display`.
- Использовать оператор `?` для краткой обработки ошибок.
- Применять паттерн "конструктор ошибок" для создания различных типов
  ошибок.
- Обеспечить информативные сообщения об ошибках с контекстом.
- Использовать крейт `thiserror` для удобного определения типов
  ошибок.
- Логировать ошибки с соответствующим уровнем логирования.
- Обрабатывать все возможные ошибки, включая ошибки ввода-вывода,
  парсинга аргументов, загрузки библиотек и т.д.

### Кроссплатформенность

- Проект должен успешно компилироваться под основные операционные
  системы:
  - Linux
  - Windows
  - macOS
  - Другие Unix-подобные системы
- Учитывать особенности работы с динамическими библиотеками на разных
  платформах.
- Использовать условную компиляцию для платформо-зависимого кода.

### Сборка проекта

- Скрипт сборки проекта `scripts/build.sh` с гибкими настройками:
  - Возможность компилировать библиотеки по отдельности
  - Возможность компилировать библиотеки по списку архитектур, ОС и
    аллокаторов
  - Параметры для выбора режима оптимизации
  - Параметры для включения/отключения различных features
- Файл Makefile с автоматизацией процесса сборки
- Dockerfile для сборки в контейнере
- README.md с описанием установки необходимых инструментов и справкой
  по сборке проекта

### Структура проекта

```text
project/
├── Cargo.toml
├── Makefile
├── Dockerfile
├── README.md
├── src/
│   ├── main.rs
│   ├── error.rs
│   ├── cpu_detection.rs
│   └── lib_loader.rs
├── core_lib/
│   ├── Cargo.toml
│   ├── benches/
│   │   └── performance_benchmarks.rs
│   └── src/
│       ├── lib.rs
│       ├── error.rs
│       └── runtime.rs
├── tests/
│   ├── integration_tests.rs
│   └── cross_platform_tests.rs
└── scripts/
    ├── build.sh
    └── benchmark.sh
```

### Тестирование производительности (benchmarks)

- Создать набор бенчмарков для измерения производительности различных
  вариантов библиотек.
- Использовать крейт `criterion` для написания бенчмарков.
- Тестировать производительность на различных наборах данных и
  сценариях использования.
- Сравнивать производительность библиотек с разными:
  - Архитектурами процессора
  - Наборами инструкций
  - Аллокаторами памяти
- Автоматизировать запуск бенчмарков через скрипт
  `scripts/benchmark.sh`.
- Генерировать отчеты о производительности в формате HTML и JSON.
- Сохранять историю результатов бенчмарков для отслеживания изменений
  производительности.
- Включить в бенчмарки измерение:
  - Времени выполнения
  - Использования памяти
  - Количества аллокаций
  - Утилизации CPU

### Выбор библиотеки

- Когда процессор поддерживает несколько наборов инструкций, выбирать
  библиотеку с наибольшим потенциальным приростом производительности.
- Реализовать механизм fallback: если оптимальная библиотека не
  найдена или не может быть загружена, использовать менее
  оптимизированную версию.
- Добавить возможность принудительного выбора библиотеки через
  переменные окружения или аргументы командной строки (для
  тестирования и отладки).

### Передача аргументов командной строки

- Основной бинарный файл передает аргументы командной строки в
  функцию `run` библиотеки в виде `Vec<String>`.
- Внутри библиотеки использовать крейт `clap` для разбора аргументов.
- Определить общую структуру аргументов командной строки, которая
  будет использоваться во всех вариантах библиотек.

## Дополнительные требования

### Документация

- Документировать публичный API с использованием doc-комментариев.
- Создать руководство пользователя с примерами использования.
- Документировать процесс сборки и установки.
- Документировать архитектуру проекта и принципы работы.

### Логирование

- Использовать крейты `log` и `env_logger` для логирования.
- Обеспечить настройку уровня логирования через переменные окружения.
- Логировать важные события и ошибки.
- Включать в логи контекстную информацию (время, модуль, уровень).

### Тестирование

- Написать модульные тесты для всех компонентов.
- Написать интеграционные тесты для проверки взаимодействия
  компонентов.
- Написать тесты для проверки работы на разных платформах.
- Автоматизировать запуск тестов через CI/CD.

---

## Сквозной план реализации проекта

### Этап 1: Настройка проекта и базовая структура

1. `Cargo.toml` - Создание основного файла конфигурации проекта с
   необходимыми зависимостями
2. `core_lib/Cargo.toml` - Настройка конфигурации библиотеки с
   поддержкой различных features
3. `.gitignore` - Настройка исключений для системы контроля версий
4. `README.md` - Создание базовой документации проекта

### Этап 2: Разработка основного приложения

5. `src/error.rs` - Реализация обработки ошибок в основном приложении
6. `src/cpu_detection.rs` - Разработка модуля для определения
   архитектуры процессора
7. `src/lib_loader.rs` - Создание модуля для загрузки динамических
   библиотек
8. `src/main.rs` - Реализация основного исполняемого файла

### Этап 3: Разработка динамической библиотеки

9. `core_lib/src/error.rs` - Реализация обработки ошибок в библиотеке
10. `core_lib/src/runtime.rs` - Создание модуля с основной логикой
    выполнения
11. `core_lib/src/lib.rs` - Реализация основного файла библиотеки с
    функцией run

### Этап 4: Тестирование и бенчмарки

12. `tests/integration_tests.rs` - Разработка интеграционных тестов
13. `tests/cross_platform_tests.rs` - Создание тестов для проверки
    кроссплатформенности
14. `core_lib/benches/performance_benchmarks.rs` - Реализация
    бенчмарков для измерения производительности

### Этап 5: Автоматизация сборки и тестирования

15. `scripts/build.sh` - Создание скрипта для гибкой сборки проекта
16. `scripts/benchmark.sh` - Разработка скрипта для запуска
    бенчмарков
17. `Makefile` - Настройка автоматизации процесса сборки
18. `Dockerfile` - Создание конфигурации для сборки в контейнере
19. `.github/workflows/ci.yml` - Настройка CI/CD для автоматизации
    тестирования

### Этап 6: Расширенная документация

20. `docs/user_guide.md` - Создание руководства пользователя с
    примерами
21. `docs/build_install.md` - Документирование процесса сборки и
    установки
22. `docs/architecture.md` - Описание архитектуры проекта и принципов
    работы
23. `rustfmt.toml` - Настройка форматирования кода
24. `clippy.toml` - Конфигурация линтера для обеспечения качества
    кода

### Этап 7: Оптимизация и финализация

25. `lib/README.md` - Документация по структуре и именованию
    динамических библиотек
26. `examples/basic_usage.rs` - Пример базового использования проекта
27. `examples/custom_library_selection.rs` - Пример принудительного
    выбора библиотеки
28. `CHANGELOG.md` - Ведение истории изменений проекта
29. `LICENSE` - Добавление лицензии проекта

---
